void bc_main(void)
exit:\n  toys.exitval = (int) st;
if ((s = bc_program_init(&vm->prog, len))) return s;
if ((s = bc_parse_init(&vm->prs, &vm->prog, BC_PROG_MAIN))) goto parse_err;
if ((st = bc_vm_init(&vm))) goto exit;
s = bc_vm_stdin(vm);
toys.optflags
toys.optflags
toys.optc
toys.optargs[i]
  if (CFG_TOYBOX_FREE) bc_vm_free(&vm);\n
bc_parse_parse(&vm
bc_parse_parse(&vm
((s = bc_parse_init(&vm.prs, &vm.prog)))
size_t len = strlen(bc_sig_msg);
write(2, bc_sig_msg, len) == (ssize_t) len
st = bc_vm_info()
'"'
'"'
BcStatus bc_vm_init(BcVm *vm)
("BC_LINE_LENGTH")
* (
FLAG_s
FLAG_q
FLAG_l
FLAG_i
maxof(
minof(
((size_t) -1)
 int
int
 1
 0
1
BcStatus bc_lex_init(BcLex *l)
bc_lex_token(l)
BcStatus bc_parse_init(BcParse *p, BcProgram *prog, size_t func) {\n
BcStatus bc_program_init(BcProgram *p, size_t line_len) {\n
if ((s = bc_lex_init(&p->l))) return s;
bc_parse_init(
bc_parse_expr(&parse, BC_PARSE_NOREAD, bc_parse_next_read)
BcStatus bc_program_pushVar(BcProgram *p, char *code, size_t *bgn)
BcStatus bc_vm_info()
(toys.optflags & FLAG_s)
(toys.optflags & FLAG_w)
TT.
toys.which->name
*n
*c
