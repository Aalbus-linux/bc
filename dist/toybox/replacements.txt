void bc_main(void)
toys.exitval = (int) st;
bc_program_init(&vm->prog, len);
bc_parse_init(&vm->prs, &vm->prog, BC_PROG_MAIN);
st = bc_vm_init(&vm);
return bc_vm_stdin();
\1vm->flags
toys.optflags
toys.optc
toys.optargs[i]
  if (CFG_TOYBOX_FREE) bc_vm_shutdown();\n  toys.exitval = (int) (\1);
bc_parse_parse(&vm
size_t len = strlen(bc_sig_msg);
write(2, bc_sig_msg, len) == (ssize_t) len
bc_vm_info()
if ((i - 1 > len || string[i - 1] != '\\\\') && c == '"') str = !str;
'"'
'"'
BcStatus bc_vm_init(BcVm *vm)
("BC_LINE_LENGTH")
* (
FLAG_s
FLAG_w
FLAG_q
FLAG_l
FLAG_i
maxof(
minof(
((size_t) -1)
 int
int
 1
 0
(0,
1
void bc_lex_init(BcLex *l)
bc_lex_token(l)
void bc_parse_init(BcParse *p, BcProgram *prog, size_t func) {\n
void bc_program_init(BcProgram *p, size_t line_len) {\n
bc_parse_expr(\1)
BcStatus bc_program_pushVar(BcProgram *p, char *code, size_t *bgn)
void bc_vm_info(void)
(toys.optflags & FLAG_s)\1
(toys.optflags & FLAG_w)
TT.
toys.which->name
s = bc_parse_parse(p)
xmalloc
xrealloc
xstrdup
*\1
\1
BcStatus bc_vm_posixError(BcStatus s, char *file, size_t line, char *msg)
void bc_num_split(BcNum *n, size_t idx, BcNum *a, BcNum *b) {\n
BcStatus bc_num_r(BcNum *a, BcNum *b, BcNum *c, BcNum *d, size_t scale,\n                  size_t ts)
\1fprintf(stderr, bc_err_fmt, bc_errs[bc_err_ids[BC_STATUS_IO_ERR]],\n\1        bc_err_msgs[BC_STATUS_IO_ERR]);
BC_INST_RET
toys.which->name
BC_VM->
\1
\1
\1;
\1
\1
\1\2\n\3\4
1;
int good = !BC_PARSE_NO_EXEC\(&vm->prs\);
\1
\1TT.vm = xzalloc(sizeof(BcVm));\n\1\2
NULL);\n  toys.optflags
0
1
char *\1
\1
\n
\1
\n
putchar
printf
fputs
fflush
\1.len
\1->len
!\1.len
!\1->len
