^BcStatus bc_vm_boot\(int argc, char \*argv\[\], const char \*env_len\)
return st;$
bc_program_init\(&vm->prog, len, exe\.init, exe\.exp\);$
exe\.init\(&vm->prs, &vm->prog, BC_PROG_MAIN\);$
st = bc_vm_init\(&vm, exe, env_len\);$
if \(\(BC_IS_BC \|\| !vm->files\.len\) && !vm->exprs.\len\) s = bc_vm_stdin\(\);[\n]*[ ]*return s;
^([ ]*)if \(BC_IS_BC\) \{\n[ ]*vm->flags
vm->flags
vm->files\.len
\*\(\(char\*\*\) bc_vec_item\(&vm->files, i\)\)
^exit:\n  bc_vm_shutdown\(\);\n  return (s != BC_STATUS_ERROR \? BC_STATUS_SUCCESS : s);
vm->parse\(&vm
size_t len = vm->sig_len;
write\(STDERR_FILENO, vm->sig_msg, len\)
bc_vm_info\(NULL\)
if \(i - 1 > len \|\| string\[i - 1\].*?str \+= 1;\n[ ]*\}$
vm->exe\.sbgn
vm->exe\.send
BcStatus bc_vm_init\(BcVm \*vm, BcVmExe exe, const char \*env_len\)
\(env_len\)
\* bcg.bc \* \(
BC_FLAG_S
BC_FLAG_W
BC_FLAG_Q
BC_FLAG_L
BC_FLAG_I
BC_MAX\(
BC_MIN\(
BC_VEC_INVALID_IDX
BcStatus bc_program_pushVar\(BcProgram \*p, const char \*restrict code,\n[ ]*size_t \*restrict bgn, bool pop, bool copy\)\n\{
s = bc_program_pushVar\(p, code, &ip->idx, false, false\);
[ ]bool
^bool
 true
 false
\(false,
true
void bc_lex_init\(BcLex \*l, BcLexNext next\)
vm->next\(l\)
^void bc_parse_create\(BcParse \*p, BcProgram \*prog, size_t func,\n[ ]*BcParseParse parse, BcLexNext next\)\n\{
void bc_program_init\(BcProgram \*p, size_t line_len,\n[ ]*BcParseInit init, BcParseExpr expr\)\n\{
vm->expr\((.*?)\)
BcStatus bc_program_pushVar\(BcProgram \*p, char \*code, size_t \*bgn, bool pop\)
void bc_vm_info\(const char\* const help\)
bcg.s([^a-z]{1})
bcg.w
bcg\.
TT\.name
s = p->parse\(p\)
bc_vm_malloc
bc_vm_realloc
bc_vm_strdup
\*restrict ([a-z])
const ([a-zA-Z]{1})
BcStatus bc_vm_posixError\(BcStatus s, char \*file,\n[ ]*size_t line, char \*msg\)
void bc_num_split\(BcNum \*n, size_t idx, BcNum \*a,\n[ ]*BcNum \*b\)\n\{
BcStatus bc_num_r\(BcNum \*a, BcNum \*b, BcNum \*c,\n[ ]*BcNum \*d, size_t scale, size_t ts\)
([ ]*)fprintf\(stderr, bc_err_fmt, bc_errs\[bc_err_ids\[s\]\], bc_err_msgs\[s\]\);
vm->read_ret
vm->name
vm->
BC_ENABLED && \((.*?)\)
BC_IS_BC && \((.*?)\)
BC_IS_BC \? (.*?) : .*?;$
BC_IS_BC && ([a-z])
BC_IS_BC && !string
[!]+BC_IS_BC \|\| ([a-z])
^[ ]*if \(BC_IS_BC\) \{\n([ ]*)  (.*?;)\n([ ]*)  (.*?;)\n[ ]*\}\n[ ]*else .*?;
BC_IS_BC;
int good = BC_IS_BC;[\n]*[ ]*good = !good \|\| !BC_PARSE_NO_EXEC\(&vm->prs\);
\{\n[ ]*if \(BC_IS_BC\) ([a-z])
^([ ]*)(BC_VM->line_len = \(uint16_t\) bc_vm_envLen\("BC_LINE_LENGTH"\);)$
NULL\);[\n]*  toys\.optflags
STDIN_FILENO
STDOUT_FILENO
char\* ([a-z])
\n#if BC_ENABLE_EXTRA_MATH // Remove.*?#else // BC_ENABLE_EXTRA_MATH(.*?)\n#endif // BC_ENABLE_EXTRA_MATH Remove
\n#if BC_ENABLE_EXTRA_MATH.*?#endif // BC_ENABLE_EXTRA_MATH\n
\n#if BC_ENABLE_HISTORY // Remove.*?#else // BC_ENABLE_HISTORY(.*?)\n#endif // BC_ENABLE_HISTORY Remove\n
\n#if BC_ENABLE_HISTORY.*?#endif // BC_ENABLE_HISTORY\n
bc_vm_putchar
bc_vm_printf
bc_vm_puts
bc_vm_fflush
BC_NUM_NONZERO\(&(.*?)\)
BC_NUM_NONZERO\((.*?)\)
BC_NUM_ZERO\(&(.*?)\)
BC_NUM_ZERO\((.*?)\)
